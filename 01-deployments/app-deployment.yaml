---
# Production-Grade Deployment with Right-Sized Resources
# 
# This deployment demonstrates enterprise best practices:
# - Properly calculated resource requests/limits
# - Health checks (liveness, readiness, startup probes)
# - Anti-affinity for high availability
# - Topology spread constraints for even distribution
# - Security context (non-root, read-only filesystem)
# - Rolling update strategy with surge control
#
# Resource Sizing Methodology:
# - CPU Request: Based on P50 usage + 20% headroom
# - CPU Limit: P95 usage + burst capacity (4x request)
# - Memory Request: Working set + 30% buffer
# - Memory Limit: 2x request to prevent OOM kills during spikes

apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp
  namespace: production
  labels:
    app: myapp
    version: v1.0.0
    tier: frontend
    cost-center: engineering
    environment: production
  annotations:
    deployment.kubernetes.io/revision: "1"
    description: "Production web application with autoscaling"
spec:
  replicas: 3  # Base replica count - HPA will override this
  revisionHistoryLimit: 10
  
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1        # Only 1 extra pod during rollout (cost control)
      maxUnavailable: 0  # Zero downtime deployment
  
  selector:
    matchLabels:
      app: myapp
      version: v1.0.0
  
  template:
    metadata:
      labels:
        app: myapp
        version: v1.0.0
        tier: frontend
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
        # Force pod restart on configmap/secret changes
        checksum/config: "{{ include (print $.Template.BasePath '/configmap.yaml') . | sha256sum }}"
    
    spec:
      # Security Context - Run as non-root
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
        seccompProfile:
          type: RuntimeDefault
      
      # Service Account for RBAC
      serviceAccountName: myapp
      
      # Topology Spread - Even distribution across zones
      topologySpreadConstraints:
      - maxSkew: 1
        topologyKey: topology.kubernetes.io/zone
        whenUnsatisfiable: DoNotSchedule
        labelSelector:
          matchLabels:
            app: myapp
      - maxSkew: 1
        topologyKey: kubernetes.io/hostname
        whenUnsatisfiable: ScheduleAnyway
        labelSelector:
          matchLabels:
            app: myapp
      
      # Anti-affinity - Don't schedule pods on same node
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - myapp
              topologyKey: kubernetes.io/hostname
        
        # Node Affinity - Prefer on-demand for production workloads
        nodeAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 80
            preference:
              matchExpressions:
              - key: node-lifecycle
                operator: In
                values:
                - on-demand
          - weight: 20
            preference:
              matchExpressions:
              - key: node-lifecycle
                operator: In
                values:
                - spot
      
      # Priority Class - High priority for production apps
      priorityClassName: production-high
      
      # Termination Grace Period
      terminationGracePeriodSeconds: 60
      
      # Init Container - Migrations, setup, etc.
      initContainers:
      - name: migration
        image: myapp:v1.0.0
        command: ["/bin/sh", "-c"]
        args:
        - |
          echo "Running database migrations..."
          /app/migrate.sh
          echo "Migrations complete"
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: myapp-secrets
              key: database-url
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 256Mi
      
      containers:
      - name: myapp
        image: myapp:v1.0.0
        imagePullPolicy: IfNotPresent
        
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: metrics
          containerPort: 9090
          protocol: TCP
        
        # Environment Variables
        env:
        - name: PORT
          value: "8080"
        - name: ENVIRONMENT
          value: "production"
        - name: LOG_LEVEL
          value: "info"
        - name: GOMAXPROCS
          valueFrom:
            resourceFieldRef:
              resource: limits.cpu
        - name: GOMEMLIMIT
          valueFrom:
            resourceFieldRef:
              resource: limits.memory
        
        # Secrets from environment
        envFrom:
        - configMapRef:
            name: myapp-config
        - secretRef:
            name: myapp-secrets
        
        # Resource Requests & Limits
        # Calculated from 30 days of production metrics:
        # - P50 CPU: 200m, P95: 800m
        # - P50 Memory: 384Mi, P95: 768Mi
        resources:
          requests:
            cpu: 250m      # P50 (200m) + 25% headroom
            memory: 512Mi  # Working set (384Mi) + 33% buffer
          limits:
            cpu: 1000m     # P95 + burst capacity
            memory: 1Gi    # 2x request for traffic spikes
        
        # Liveness Probe - Restart if unhealthy
        livenessProbe:
          httpGet:
            path: /health/live
            port: http
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          successThreshold: 1
          failureThreshold: 3
        
        # Readiness Probe - Remove from service if not ready
        readinessProbe:
          httpGet:
            path: /health/ready
            port: http
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 2
        
        # Startup Probe - For slow-starting applications
        startupProbe:
          httpGet:
            path: /health/startup
            port: http
            scheme: HTTP
          initialDelaySeconds: 0
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 12  # 60 seconds total (12 * 5s)
        
        # Security Context
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
            - ALL
        
        # Volume Mounts
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: cache
          mountPath: /app/cache
        - name: config
          mountPath: /app/config
          readOnly: true
      
      # Sidecar - Logging agent
      - name: log-shipper
        image: fluent/fluent-bit:2.1
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 128Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: fluentbit-config
          mountPath: /fluent-bit/etc/
      
      # Volumes
      volumes:
      - name: tmp
        emptyDir: {}
      - name: cache
        emptyDir:
          sizeLimit: 1Gi
      - name: varlog
        emptyDir: {}
      - name: config
        configMap:
          name: myapp-config
      - name: fluentbit-config
        configMap:
          name: fluentbit-config

---
# ServiceAccount with minimal RBAC permissions
apiVersion: v1
kind: ServiceAccount
metadata:
  name: myapp
  namespace: production
  labels:
    app: myapp
automountServiceAccountToken: true

---
# ConfigMap - Application Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
  namespace: production
data:
  app.conf: |
    # Application configuration
    server.timeout=30s
    server.keepalive=60s
    cache.ttl=300s
  
  database.conf: |
    # Database connection pool
    db.max_connections=50
    db.idle_timeout=300s
    db.max_lifetime=3600s

---
# Fluent Bit ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentbit-config
  namespace: production
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush        5
        Daemon       Off
        Log_Level    info
    
    [INPUT]
        Name              tail
        Path              /var/log/containers/*.log
        Parser            docker
        Tag               kube.*
    
    [OUTPUT]
        Name              stdout
        Match             *

